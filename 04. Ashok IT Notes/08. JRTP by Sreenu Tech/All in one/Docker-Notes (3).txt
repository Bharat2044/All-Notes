Docker
======

	1. Introduction?
		a. what is virtualization? adv & drawbacks?
		b. what is containerization? adv?
	2. What is containerization technologies, why do we need to use it?
	3. The architecture of the docker
	4. docker workflow
	5. docker software installation
	6. docker image
	7. docker container
	8. docker directives
	9. docker volumes
	10. docker networking
	11. docker container lifecycle
	12. docker container registry
	13. Realtime examples on docker


==============================================================================

Docker Introduction:
===================

 Virtualization:

Virtualization is technic or a mechanism through which we can run multiple parallel isolated, environments on single computer/machine through the help of using Hypervisor software
	
i.e. The process of splitting single machine into multiple machines is called virtualization
		

advantages:
===========

	1. each virtual machine can run their own os independent of the host os of the computer
	so that we can easily deploy and run the software applications on different operating 	system environments

	2. software applications which requires dedicated operating system of their own by creating 
	   virtual machine and installing the operating system on the vm separately

	3. Since all the virtual machines are isolated from each other and runs independent of the host
	   operating system, we can implment more security

		i.e if the host machine has compromised on security then guest machines are not impacted
	            as each vm has runs on dedicated os

	4. It is suitable for deploying and running applications that are long running processes

 dis advatanges:
 ===============

	1. VM's are heavy weight : dedicated os + resources like cpu, ram 
		
		i.e. It consumes lot of system resources in running the software applications

	2. Since VM's are heavy weight (i.e. huge in size in diskspace) and are not portable to be carried
	   acorss all the environments

	3.  Difficult to acheive CICD

	4. More cost as we need buy the os licences for all the vms

	5. Difficult to scale the vm's


To overcome all these problems, market has been introduced containerization technologies

	Containerization =  package/combine ( application code + software + configuration )
		|
	Deploy this package in all the environments, make sure it should work in all the environments/systems


 Containerization
 =================
"Containerization is technic through which we can package software applications and the corresponding
libraries/binaries which are required for running the application"

-->Multiple containers can run in parallel isolated from each other on the same machine


Advantages:
===========

	-->The containers are lightweight, in each container the operating system is not installed rather only libs/bins are 
	   packaged as part of them
	-->Since we don't install operating system as part of the container, the container images are very small in size
	   and can be easily portable across the computers
	-->Since the containers are very small in size, It is good for CICD
	-->We can optimize the physical resources of the computer by running lot of programs in parallel
	-->patching and upgrading is very easy while using containerization

Dis Advantages:
===============

	-->The containers always shares the same operating system of host, so we can't install independent operating system
	   of that host computer while using containers
	-->containers are not highly secured, if the host has bee compromised then containers also compromised
	-->only suitable for short running application


Q) when should we use virtualization and when containerization?

Sol : If we want share a physical computer and its resources between 2 parties where they wanted to run their applications on
      dedicated environment then we should use virtualization only

      If we want to run software applications isolated from each other, then we can go for containerization		
		

There are lot of containerization technology supported tools are available in market

	1. Docker
	2. Redhat Openshift		====> out of all these, Docker is most popular
	3. Mesosphere
	4. Microsoft Container

Docker :

	-->Docker is a word that is derived from dock-worker, dock worker is a job of person who loads containers and un loads the
	   containers in a ship from where it has been named as 'Docker'

	-->Using docker we can implement containerization technologies where we can package software applications into docker images
	   and ship them. People can run applications packaged in docker isolated from other as containers.


	Docker workflow
		
		Developer ------------->Package------------->Ship
		Developer -------->build--->package---------->release


	How to package the Software Application : Docker Image
	How to run the packaged application	: Docker Containers

		=====================================================================================
		|Docker Image = libs and bins + appication code + required softwares + configuration|
		=====================================================================================

		Docker image is a packaged with all the required details to run the application

		Docker Container = execute/run the docker image then docker container will be created.



	Developer---- Dockerfile---->Docker engine (Docker Software )---->Docker image ---> Docker Container

How does the containers are kept isolated from each other and running on the same machine?

Sol :  As part of the linux operating system, there are lot of enhancements and features to be added to make the containers work
       on the same machine isolated from each other.

	1. Linux Namespace		2. Control Groups ( cgroups )		3. Union File System

	

	1. Linux Namespace :

		-->Docker uses below namespaces of the linux os to run containers are isolated

			1. pid = run  the container in a separate process namespace
			2. net = network namespace managing the network interface
			3. ipc = inter process communication namespace
			4. mnt = filesystem mounts
			5. uts = unit timesharing

	2. Control Groups ( cgroups ):

		-->Docker Engine uses cgroups of the linux operating system in sharing the physical resource of the computer
	 	   and limiting their usage by the container


	3. Union File System :

		-->Docker container images are packaged and assembled based on union filesystem technic




Docker Architecture:
===================

There are 3 parts in docker architecture : 1.  Docker CLI    2. Docker Engine	3. Docker Container Registry

     
       
  1.  Docker CLI :

		-->docker CLI stands for docker command line interface, which is provided as part of the docker install
		-->There are handful docker commands that allows the users to communicate with  docker engine in managing
		   images and containers     



2. Docker Engine (Docker Software) : 

	-->It is the main component that takes care of running docker containers from an docker image
	-->There are 3 main components  : 1. docker daemon	2. docker containerd	3. runc
	

	1. docker daemon:
	   =============

		-->It is a rest api endpoint through which docker engine is exposed to the users
		-->The users can interact with docker engine by using docker cli, so that cli will send the commands over the
	           network using http protocol and communicate with docker daemon
		-->Docker daemon will receive the request (docker commands) from  users and will ask containerd to perform
		   appropriate operation

	

	2. containerd : 

		-->containerd is a component build by docker team, which takes care of building the images, pulling images
		   from container registry, convert these images into OCI image fromat and passes it as an input to the
		   runc for running a docker container

		   OCI = 1. Open Container Intiative Specification
			 2. It will standardize the way images has to build and the way containers are executed and manage the
			    Underlying operating system

	3. Runc :

		-->It is an low level component that interact with the underlying operating system of our computer in creating/
		   destroying/managing the container based on the oci image specification
			 

 
3. Docker Registry:

	-->DCR (Docker Container Registry) is a repository where docker images are published and distributed across the 
	   envrionments/world
	
	-->The docker has provided a "http://hub.docker.com" docker registry in whoch people around the world build their own
	   images publishes and distriubted to the world


Docker Objects

	|-1. Docker Images
	|-2. Docker Containers


	Software Application Source Code ---->Build (Compile , Jar/war) ----> Deploy the application --->Run the application


	
	We should build docker image and get container from image

	To run Software Application we need below softwares are required

		1. JDK
		2. Tomcat	 + Instruction	
		3. Application
		

 Software Application to docker image steps:
 ===========================================

	1. Devops Engineer will discuss with dev team, undestand the software application requirement

	2. write the docker file

		Dockerfile
		----------

			1. Get the jdk software (jdk image)
			2. Get the tomcat software (tomcat image) + libs and bins ( To communicate with host operating system )
			3. configuration of jdk, tomcat
			4. Get the application code
			5. add the instruction to run the application ( base images like alpine, ubuntu ..etc) .
			6. get ubuntu
			:
			:

	3. Give this dockerfile to docker engine, which will execute 3 steps internally (1. docker daemon 2. containerd  3. runc)

		>docker build -t imagename dockerfile

		o/p : dockerimage  ( once the docker image has been created you can't edit or modify that imge )

		
	4. Push the images into dockerhub registries (*.images)

	5. Get/Pull the image and run the image

		>docker pull imagename : download image from docker container registry to computer
		>docker run imagename  : docker container will be generated ( i.e. application is up and running )

	6. Access the application

======================================================================================================


Docker Advantages:

	1. To maintain the consistency in all the environments
	2. Cost Optimization. i.e. cost saving


	Before Docker
	============

		1. mysql software -- while installing mysql operating system will allocate fixed resources like CPU and RAM
				     once it is fixed either mysql will utilize or may under utilize

		2. Tomcat Software

		3. JDK Software

		 :
		 :
		If all these software will not utilize allocated resources then these are wasting the system resources


	To overcome this issues, most of the softwaare vendors has been releasing their corresponding docker images along with 	existing supported formates

		JDK    ----------- .exe          .zip		.image
		Tomcat ----------- .exe          .zip           .image
		MySQl  ----------- .exe          .zip           .image
		Jenkins ---------- .exe          .zip           .image
		sonarqube -------- .exe          .zip           .image

		:
		:


							Docker Images
							   |
						-----------------------------------------
						|					|	
					Predefined Image			Userdefined Image

					jdk				1. according to the application requirements development
					tomcat				   team and devops team will have discussion
					mysql				2. devops team will prepare the dockerfile
					sonarqube			3. build the image from docker file
					jenkins				4. push the image into docker registry
					:				
					:

	1. Every Software vendor team has written dockerfile
	2. build the image
	3. push the image into docker container registry


#1. Docker Image:

	-->Docker image is a file packaged with 

		1. application binary (.jar/.war)
		2. software packages required to run the application ( like jdk, tomcat..etc )
		3. instructions in running the application
		4. bins/libs = that enables to communicate with docker engine

	all these together to run an application in an isolated environment of a computer

	
	Dockerhub is an container repository/docker registry hosted by docker team to help the people around the world to 
	publish and distribute thier own images

	To publish an docker image into a docker registry per each image we need to create an repository into which we can publish
	one image, There are 2 types of repositories

		1. public repository   : The image will be published into public repository will be open to the world and anyone
				         can use it or modify it

		2. private repository :  These repositories are used by individuals/corporate who are working on commercial/private
				         objects and don't want expose these images to the public world
					 These images can be delivered/distributed across the stages of our project.
		

	There are lot of docker images are created and published as part of docker hub registry we can categorie these image into 
	2 types

	1. docker officals/certified/verified images :

		-->These images rare created by docker/partners and are verified by the docker team and published as part of the
		   repository

	2. community images :

		-->any of the users who wanted to contribue for opensource stack can create and publish their own images which
		   are called community images and should used at our own discreation.



	For our software application inorder to containerize the application, we need to build our own docker image
	packaging the applications with instructions and bins,libs
	
	It is an usual practice to build the image of our own by extending the existing docker images

	The docker team has provided a base docker image which containers bins/libs which can used as base image from
	which we can extend and create our ownimage which is called 'alpine' of size 2 mb

	use ubuntu image instead of alpine image

	Q) Why docker images are read only?
	Q) docker images are layered and stackable?
	

#2. Docker Containers:

	-->A running process or a programs that is created out of an existing docker image that runs isolated from other process	   is called an container
	-->The lifetime of the container is dependent on the amount of time the application is running, once the application 
	   inside the container terminates the container also will get terminated

		"docker containers will be created from an docker image"

		docker container is an instance of a docker image

		we can create multiple containers from an one docker image

Docker Images:
=============

	-->There are lot of opensource docker images provided by the docker team, partners and people around
	   the world and has published to the docker hub registry

	-->If we want package our software application as docker image we can take any of the existing
	   from the dockerhub registry as a base image

	-->There are few images considered as base image like alpine, ubuntu ...etc


			prepare our own docker image  =  application binaries + software packages + 
							 configuration + libs and bins (baseimage)	

			To build our docker image, we must depend on 1 or more predefined docker images

				one docker image is mandatory ie. base image
				other docker images are optional like jdk, tomact..etc based on our application
				requirements

	
	-->The docker images are layered and stackable

	1. while we are building the image, if the docker package the base image into each application
	   the base image will be duplicated which will results in

		a. wasting the harddisk space in creating mulitple applications docker images with same
	           base image

		b. bandwidth consumption (network calls) in publishing/distributing the images will be high


	To overcome the above problem docker has comeup with layered and stackable images

	whenever we are creating an application as docker image, in our docker image we refer the existig image
	base image calld "gold copy", which is not packaged or cloned inside our image or not extended
	rather in our image we holde the reference of the goldcopy or image only, on top of application
	binary are placed and packaged.


	i.e. While building the image first time, if that image required base image then it will goto docker 	registry and download into local system. If the same base image required for multiple other docker 	images then it will check if the base image available in local system, if it is available get it from
	there by holding the reference else it will go docker registry

==============================================================================================================

Docker Software Installation:
=============================

	We can install docker software in 

		1. windows os : from windows 10 onwords we can install and run docker containers
				Docker team has provided software called "docker-desktop-windows"

			-->It is in the form of .exe file , Download docker software freely from 				   https://docs.docker.com/desktop/install/windows-install/

			-->double click on docker.exe file and click on next and finish
			

		2. ubuntu linux os   :

			1. sudo apt update
			2. sudo apt install -y docker-ce
			3. docker systemctl docker	
		 


		3. mac os     :   
			
				from windows 10 onwords we can install and run docker containers
				Docker team has provided software called "docker-desktop-windows"

		4. Install docker in aws EC2 machine
	

		

	There are 2 versions of the docker

		|-docker community edition	we have to install community edition, which is an opensource
		|-docker enterprise edition



  -->Once the docker software has been installed then check the version of the docker

		>docker -version

 -->docker desktop will be provided by docker software, which has docker engine already

 -->We can connect docker registry using docker desktop
==============================================================================================================

what is importance of envrionments
what is virtualization
what is containerization
virtualization vs containerization
docker architecture
	|-docker cli
	|-docker engine
		|-docke daemon : it will expose rest api to the users, user will use this api to send the 
				 docker commands to docker engine
		|-containerd   : build the image as per oci (open container intiative specification) standards		
		|runc	       : interact with host operating ystem to create/destroy/manage tht container
			         based applications
docker workflow:

	develop ---> build --->package--->ship
	develop ---> build --->package--->release

docker objects

	|-docker images	
		|-It is file which contains software libariaries, instructions, application binaries in
		  running the software applications along with libs and bins required for communicating
		  with docker engine.
		|-docker images are read only
		|-docker images are layered and stackable

	|-docker container
		|-It is a program or process that is created out of an docker image which is under execution
	          is called an "container"

		 docker container is an instance of docker image
		 we can create many container instances from one docker image

========================================================================================================

  Docker images

	|-pre defined images  --> These images already available in docker registry
			      --> Get these images and run the image to get the containers. 
				 i.e. application is up and running
													
	|-user defiend images

			     -->These image development team should be prepared

					1. write dockerfile
					2. prepare image
					3. publish image
					4. run the image		



	How to prepare the images as per our application needs, we will see later

	How to prepare the containers with existing docker images


Docker Container commands:
==========================

	1. Get the list of container

		>docker container ls

	    we can see the running containers on docker workstation or on docker daemon

		CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

		
		CONTAINER ID : docker engine creates unquie id and assign it to the container
		IMAGE  : whom this container as been created
		COMMAND : used in launching the container
		CREATED : when the container has been created
		STATUS  : current status of the container
		PORTS   : ports exposed out of the container
		NAMES   : for container the docker engine generates a unique random names and assign it
			  for easy reference

			  We can manage the container using either using contianer id or NAME of the container


	2. How to run a docker container interactively

		>docker caontiner run -it image:tag command

		ex : docker container run -it ubunutu:20.0 bin/bash



	3. how to run the container

		>docker container run imagename:version

		>docker container run mysql
			
		If the version is not mentioned then it will take as latest version

	

	docker engine upon receving the request for running a docker container it checks whether the docker
	image tag with specified in the local docker image workstation, if it is not available in local
	then it will connects to the docker container registry and pulls the docker image on the
	docker workstation.

	Once the image is available on the docker workstation, the docker engine creates an docker container
	out of the image and kicks start the default command written as part of the image in running the
	program inside the container.

	
	4. How to see all the containers on the macine

		>docker container ls -a

		-a = all the containers irrespective of their status

		C:\Users\HP>docker container ls -a
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS                     PORTS     NAMES

374d645913c5   ubuntu    "bin/bash"               3 minutes ago   Exited (0) 2 minutes ago             peaceful_thompson
e1d803f9696a   ubuntu    "/bin/bash"              4 minutes ago   Exited (0) 3 minutes ago             zen_jennings
6ef45b775829   ubuntu    "bin/bash"               4 minutes ago   Exited (0) 4 minutes ago             keen_edison
6c1047d864ce   mysql     "docker-entrypoint.s…"   8 minutes ago   Exited (1) 8 minutes ago             dazzling_shaw



	-->when we start the container means, the application has been started
	   after completing the execution of the application, docker engine terminates the container
	   but will not removed/destroy the container, becaue people/programmers may want to collect the logs
	   generated by the container.



	5. How to remove the terminaed container?

		>docker container rm CONTAINER ID/CONTAINER NAME
		C:\Users\HP>docker container rm 6ef45b775829
		6ef45b775829

	6. how can we see all the container are running
	
		1. >docker container ls 
		2. >docker container ps

	7. how to stop an running container

		>dcoker container stop CONTAINER ID/CONTAINER NAME

	
	8. How to forcible stop and remove a running container

		>docker container rm -f CONTAINER ID/CONTAINER NAME // forcibly remove an running container

	9. How to remove all the stop/exited containers at one shot?

		>docker container prune

==================================================================================================================================================

26-APR-2024

 Docker Objects		
 --------------
|---Docker Images 	: It is file which contains required information to run the application 
		    		( software appn + software packages +  bins and libs + configuration )

|---Docker Containers	: Container is an instance of an image
			: Create a program or process out of an docker image which is under execution is called 
			  container.

How to work with Docker Container:
==================================

	Assume that docker images already available ( predefined images, user defined images ), use those images How to create the
	Containers.

	1. How to run a container interactively

		>docker container run -it imagename:tag command
		>docker container run -it ubuntu bin/bash

		The above command will create docker container out of an docker image
		-it = stands for interactive execution saying execute the command specified

		Docker engine will check ubuntu image avialable in local docker workstation ( local cache) or not
		if it is available it will get it from there, else it will connect to docker registry to download the ubuntu
		image and store in docker workstation.

		Once the ubuntu image is available in local docker workstation then it will create the docker container out of an
		image

		Here command (bin/bash) is a optiona, if we will not provide the command then default command will be executed


	2. How to see the running container on the docker workstation or on docker daemon?

		>docker container ls

	3. How to see all the docker containers on the machine?

		>docker container ls -a 
			
			or

		>docker containre  ps


	Note : Container start means, program execution will start

		>docker container run mysql --- mysql container will be created out of an mysql image  . i.e. mysql server started
		>dcoker container run tomcat -- tomcat container will bt created out of an tomcat image. i.e. tomcat appn started

	Once the program execution will be completed then docker engine will terminate the docker container, but will not
	remove/destroy the docker container, because the developer may want to collect the logs generated by the container 
	


	 CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS                     PORTS     NAMES



		STATUS = STOPPPED | Running | Exited 



	4. How to remove a terminatted container

		>docker container rm containerid/containername
	
	5. How to stop a running container

		>docker container stop containerid/containername

	6. How to forcible stop and remove a container

		>docker container rm -f id/name

	7. How to remove all the stopped/exited containers at one shot?

		>docker container prune

	8. How to run a docker container with a given name

		>docker container run -d --name containername image:tag
		>docker container run -d --name tomcatserver tomcat:9.0 (if tag is not provided then latest version will come)

	9. How to see the container logs
	>docker container logs id/name
	>docker container logs -f id/name where f = stands for flow, means scroll through the genrating logs the containr appn

	10. How to enter inside the container that is running

		>docker container exec -it containerid/name command

		>docker container exec -it --name tomcatserver tomcat:9.0

	11. How to check the details of a container?

		>docker container inspect id/name

		It will displays the entire information about the containers like cpu, memoty, storage, id, image, interface card
		ip address, portnos exposed...etc

	

		

===============================================================================================================

 Docker Image Management Commands

	1. How to see all the images on docker workstation?

		>docker image ls

	2. How to see all the details of the image like author, platfom ..etc

		>docker image inspect image:tag

	3. How to remove an existing docker image from local cache?

		>docker rm image:tag   ( fail when container is created of that image )
		>docker rm -rf image:tag (-f forcibily remove the image )

	4. How to remove all the unused images on the workstation?

		>docker image prune

	5. How to pull/get the a docker image from a docker registry( dockerhub.com, jfrog.com, ecr, acr..etc )

		>docker image pull image:tag 
		( docker image will pull/get from docker registry https://dockerhub.com )

	6. How to push a docker image into docker registry
	
		>docker image push image:tag

	7. How to connect to docker registry?

		>docker login -u username -p password

	8. How to export docker image into a file?

		>docker image save image:tag -o outputfile.tar

	9. How to import docker image from a file?

		>docker image load -i filename.tar

	
	10. How to build a docker image?

		>docker image build -t imagename:tag dockerfile location/path

	
		 
=============================================================================================================

Docker Container Management Commands -- 10 commands
Docker Image Management Commands     -- 10 commands

Note : Till we have seen docker image management commands like 
		
		1. see the image list? >docker image ls
		2. how to connect to docker registry? >docker login -u username -p password
		2. get/pull the image from container registry? >docker image pull imagename
		3. push the image into container registry? >docker image push imagename
		4. remove the image ? >docker rm imagename
		5. remove the image if the conatiner is already created? >docker rm -f imagename
		6. how to remove all the unused docker images? > docker image prune
		7. how to export image into file > docker image save imagename:tag -o filename
		8. how to import the image into file >docker image load -i filename	 
		9. how to see the details of the image? docker image inspect imagename
		:

We didn't discuss about how to create an image

All the above commands are used on image. i.e. if the image is already created how to manage the image.
but we should know how to create our own image

To create our own image, developer should know how to write docker file, because docker image should be created
by dockerfile.

once docker file has been complted then generate/create the docker image

	>docker image build -t imagename:tag dokcerfile


docker engine will read the DockerFile, It will create the docker image based on the instructions provided in Docker file

Dockerfile
===========

	--------
	-------- =====> list of instructions
	-------- 	
		


Write the Dockerfile with instructions, The instruction that we write in Dockerfile are called "Docker Directives"

-->Using docker directives we are going to achive 2 things

	1. package all the required details like bins/libs, software packages, software application
	2. write container execution commands that has to be executed at the time of launching the container
	   based on image.


-->Docker directives are 2 types

	1. build image instruction : To build the docker image
	2. container instruction   : To run the container. i.e. to launch the application

Docker image will not package the source code of our application rather it is used for package executable
application with dependencies and distribute across.

Docker image instructions - directives:		Docker container instructions - directives:
======================================		===========================================

	1. FROM						1. CMD	
	2. ARG						2. EXPOSE
	3. RUN						3. ENTRYPOINT
	4. ADD						4. HEALTHCHECK
	5. WORKDIR					5. VOLUME
	6. COPY
	7. LABEL
	8. ENV


 Imp Note :
 ==========

	-->The image instructions/directives are executed by the docker engine to build the docker image

		>docker image build/... <imagename> <dockerfile>

	-->The container instructions that are executed only at the time of launching the container to run
	   the application packaged inside the image. i.e. Container instructions will be executed at the time
	   of launching the containers only
	
		>docker container run/... <imagename>

	
-->For every project to be packaged as an image, we need to create dockerfile in each project
-->Dockerfile doesn't have any extension

enrollment-service
 |-src
    |-main
	|-java
	|-resources
    |-test
	|-java
	|-resources
|-pom.xml
|-Dockerfile
	|-image instrucitons + container instructions
|-target
   |-.jar or .war


offer-service
 |-src
    |-main
	|-java
	|-resources
    |-test
	|-java
	|-resources
|-pom.xml
|-Dockerfile
   |-image instrucitons + container instructions
|-target
   |-.jar or .war	
				

Docker Build Context?

	-->1. write docker file with docker directives and place it within a directory
	-->2. when we asked build the image, It will transfer entier content of the directory in which
	      Dockerfile is present.
	-->3. The directory under which we run the docker build is called "build context"

	/offer-service> docker image build -t imagename:tag . // bydefault docker engine looks for Dockerfile



Q) Can we write our own docker file with a different name?can we build docker image by locating outside the
   directory in which Dockerfile is there?

Sol : Yes, we can create docker file with different name, we should pass that dockerfile explcitly 
      to docker engine

	>/offer-service> docker image build -t imagename:tag  offersDockerfile

======================================================================================================
02-may-2024

How to write the Docker file

	
1. FROM directive:

	Dockerfile
	----------
	 #ESCAPE=' '
	 #SYNTAX=docker/docker-1.0.1
	 FROM ubuntu:20.04


	There are 2 types of directives supported by docker

		1. SYNTAX
		2. ESCAPE

	The parser directives looks like comments in docker file, but those are special instructions which are
	interpreted by the docker engine

	
	-->SYNTAX is an parser directive that is used for importing another docker file in which new syntaxes
	   are defined, so that we can use them as part of our Dockerfile in building the image.

	-->The parser directives works only with a new docker called 'build kit' which is more advanced engine
	   in building docker image

	-->There are lot of advantages with build kit

		a. It will transfer the files from docker build context to docker engine
		b. import external docker files in adding new directives and features in building images
		c. detects and skips unused build stages/layers
		d. parallel build independent images


	Syn :  #SYNATAX docker/Dockerfile: experiment
	       #ESCAPE='


1. FROM directive:

	-->Always while building the docker image of our own we need to extend our image from one of the 
	   base images. So that the underlying binaries/libraries required for communicating with docker engine
	   
	-->We should included required base image using FROM directive
	


 Syn : FROM --platform=platform name image: tag ( here platform is optional to be used )
       FROM --platform=Linux/arm64 ubuntu: latest

2. ENV directive:

	-->It is used for defining environment variables to be passed while building the image, so that
	   those variable are available while executing the container. 	

	 ex : our image required software packages like JDK, tomcat or maven..etc
	      unless we configure the PATH environment variable pointing to the directory locations of these
	      software's, we can't run directly.

	      we should set the environment variables to be included as part of image build

	Dockerfile
	==========

		FROM ubuntu
		ENV JAVA_HOME=JDK_location
		ENV TOMCAT_HOME=TOMCAT_location
		
		
		>docker image build -t imagename:tag .	
		
			 	
	Note : Instead of hardcoding the ENV variables in the Dockerfile we can pass them as in input while
	       building the docker image

		
		>docker image build -t imagename:tag --env-file=variables.env


variables.env
=============
ENV JAVA_HOME=JDK_location
ENV TOMCAT_HOME=TOMCAT_location



	Dockerfile
	==========

		FROM ubuntu
		ENV JAVA_HOME=JDK_location
		ENV TOMCAT_HOME=TOMCAT_location
		ENV db.driverClassName=com.mysql.cj.jdbc.Driver
		ENV db.url=jdbc:mysql://10.0.0.150
		ENV db.username=root
		ENV db.password=root

		Since these values will change from env to env, instead of defining these environment values
		as part of the image, we can pass these values during the time of running the container

		>docker container run -e VAR1=VAL1 -e VAR2=VAL2  -e VAR3=VAL3  imagename:tag


How many ways we can pass the ENVIRONMENT variables in docker?

	There are 2 ways there

		1. we can define them as part of image and will be included inside the image during the build
		   and is available while running the container. i.e. static variable we can use this

		2. if the environment variables are dynamic then we can pass during launching the container



#3. ARG directive :

	-->It is used to pass the arguments while building the image, we can parameterize the docker image
	   build process process through ARG directive

	-->The ARG we passed are only available within Dockerfile only and are not accessible during the
	   runtime while lunching the container. 


Dockerfile
==========

	FROM ubuntu
	ARG JDK_SW
	RUN apt install -y $JDK_SW

	>docker image build -t sampleimage:1.0 --build-arg JDK_SW=openjdk-11-jdk


	ARG - build time inputs in parameterizing the docker image builds
	ENV - can be used both during image build also and at runtime also
	

#4. LABEL directive:

	-->It is used for defining key=value pair in Dockerfile which is used for documentation of the image

Dockerfile
==========
	FROM ubuntu
	LABEL AUTHOR=sreenu
	LABEL IMG_VERSION=1.0
	LABEL LICENCE=apache licence 2.0

	ARG JDK_SW
	RUN apt install -y $JDK_SW

#5. MAINTAINER directive: 

	-->Used for defining author of the image, and is deprecated and no more in used in flavour of LABEL

#6. RUN directive :

	-->It is used for running any command during the time of building the image the output by the RUN
	   directive will be written as a layer on top of the image always

	-->RUN is an image building instructions which is executed during the time of building the image
	   and used for installing the software packages as  part of the image itself


Dockerfile
==========

	FROM ubuntu					
	RUN apt install -y openjdk-11-jdk		|maven layer |
							------------- 
	RUN apt install -y tomcat			|jdk 11      |
							-------------
							| ubuntu     | 
#7. COPY directive

	-->It is used for copying the files from docker build context to the docker image


	Dockerfile
	==========

		FROM ubuntu
		Copy target/filename.jar /filename.jar



Simple usecase:
===============

	#1. install jdk11

	   >sudo apt install -y openjdk-11-jdk

	#2. install git

	    >sudo apt install -y git

	#3. install maven

	    >sudo apt install -y maven

	#4. write source code or download source code

	#5. build the maven project


With Docker:
============

	FROM ubuntu
	RUN apt update -y
	RUN apt install -y openjdk-11-jdk
	RUN apt install git
	COPY target/filename.jar /filename.jar

	CMD java -jar filename.jar com.sreenutech.offerservice
	

#8. ADD directive

	-->It is similar to COPY directive only, but only the difference is COPY directive will copy files
	   from docker build context to the image
	-->ADD is used to copy the files from docker build context to the image and 
   It will download the files from remote systems based on URL and can add into the docker image as well

=============================================================================================================

03-May-2024

	Docker Directives

	1. FROM
	2. ENV
	3. RUN
	4. ARG
	5. COPY
	6. LABEL
	7. MAINTAINER
	


1. FROM : It is used to get the base image into our image, so that our image can talk to docker engine with the
	  help of base image libs/bins

2. ENV  : It is used defining environment variables

	-->Env variable can't be passed as an input during image building process, those has to be defined
	   in Docker file itself with values (only static variables)

	-->env variables can be passed at run time while launching the container

3. ARG : Using ARG directives we can pass dynamic input for image building process

4. RUN : It is used for running any command during the time of building the image, the output generated by
	 RUN directive will be written as a layer ontop of the image always.

	It is used for installing the software packages as part of the image itself.
	   

5. LABEL : it is used for defining key=value pair in Dockerfile which is used for documentation of the image

	
6. MAINTAINER : It is an another directive used for defining the author of the image and is deprecated and no
	        more in used in favour of LABEL

7. COPY :  It is used for copying the files from docker build context (  folder files of in which Dockerfile 	   present )
	   to the docker image

8. ADD : It is similar to COPY directive but only difference between ADD and COPY is

	COPY  : only copies the files from docker build context to the docker image
	ADD   : Copy the files from docker build context to the docker image and also download the files from
	        remote system based on URL and can add into docker image

	
9. WORKDIR : The COPY, ADD< CMD, ENTRYPOINT, RUN ...directives works based on relative from WORKDIR location

	-->If we don't specify the WORKDIR location in the Dockerfile the docker engine by default creates
	   the WORKDIR location "/" and executes the command

	-->It is always recommended set the WORKDIR location using which we need to apply the COPY, RUN, ADD
	   CMD, ENTRYPOINT..etc directives rather than specifying the full directory path
	   so that docker file becomes easily maintainable

Dockerfile:

	FROM ubuntu:24.0
	ENV JAVA_HOME=/var/softwares/jdk-8
	ENV PATH=$PATH:$JAVA_HOME/bin
	RUN mkdir -p /var/software
	RUN mkdir -p /var/applications
	ADD https://downloaded.java.net/openjdk/jdk11/....../openjdk.tar.gz /var/software 
	RUN tar -xvf /var/software/openjdk.tar.gz
	RUN rm /var/softwares
	COPY target/filename.jar /var/applications
	CMD java -cp jarfilename classname


Dockerfile:

	FROM ubuntu:24.0
	ENV JAVA_HOME=/var/softwares/jdk-8
	ENV PATH=$PATH:$JAVA_HOME/bin
	RUN mkdir -p /var/software
	RUN mkdir -p /var/applications
	WORKDIR /var/software
	ADD https://downloaded.java.net/openjdk/jdk11/....../openjdk.tar.gz  
	RUN tar -xvf openjdk.tar.gz
	RUN rm /var/softwares
	COPY target/filename.jar /var/applications
	CMD java -cp jarfilename classname

	
CMD directive:

	-->It is used for executing an instructions/commands during the launch of the container
	-->CMD is an container instructions that is used for making the executable container
	-->We need to write one CMD in a Dockerfile to run/execute the application packaged inside the image
	-->Incase if we have written multiple CMD directives in the Dockerfiles only last CMD instruction
	   will be executed ignoring all the other instrusions

	-->There are 3 ways we can write the CMD

		1. CMD["execute", "param"]  = execute param

		2. CMD["param1", "param2"]  = used in conjuction with Entrypoint ( )

		3. CMD exetuable  param1 param2 = shell file
			 

	ex : 

		1. CMD["echo", "$PATH"]

		1. CMD["bash", "-c", "$PATH"]



ENTRYPOINT :

	-->It is used for making an docker container executable, it is an container instructions


CMD vs ENTRYPOINT

	-->CMD is used for making an docker container executable, but when use CMD directive for building an
	   executable container the user can override the CMD by passing argument while launching the container

		>docker container run image:tag overridecommand

	-->Where as ENTRYPOINT we can't override the command we are executing inside the ENTRYPOINT


Note:

	1. CMD is used for making an container executable, It is the default CMD which a container will be
	   executed

	2. we can always override the default CMD in the Dockerfile by passing command explicitly

	3. We can hase any no.of CMD written in the Dockerfile but only last CMD will be executed

	4 If we want execute multiple commands while launching the container we have 2 options

		a. write one shellscript program in which write all the commands you want to execute and 
		   run the shellscript in the CMD

		b. we can write CMD in shellform by concatenating 2 commands using

			CMD cmd1&&cmd2


ex 1: Dockerfile

	FROM ubuntu:24.0
	CMD [ls]
	CMD ["echo", "$PATH"] //only last one will execute

ex 2 : 	sample.sh

	   ls
	   echo "$PATH"

	
	Dockerfile
	  FROM ubuntu:24.0
	  COPY sample.sh
	  RUN chmod U+X sample.sh
	  CMD ["./sample.sh"]
		
	
If both CMD and ENTRYPOINT together, it will ignores the CMD and execute ENTRYPOINT only

CMD before ENTRYPOINT

	Dockerfile
	-----------
	
		FROM ubuntu:24.0
		CMD["echo", "CMD instructions here"]
		ENTRYPOINT["echo", "ENTRYPOINT Instructions here"]

CMD after ENTRYPOINT, Here CMD acts a parameter to the ENTRYPOINT instruction

	Dockerfile
	-----------
	
		FROM ubuntu:24.0
		ENTRYPOINT[ls]
		CMD[-l]



How to write the docker file    : FROM, COPY, EXPOSE, ENTRYPOINT

How to build the image 		: >docker build -t imagename:tag .

How to connect docker registry :  >docker login-u uname -p passwd

How to push the image into     :  >docker image push imagename:tag	
docker registry

How to pull the image from     : >docker image pull imagename:Tag	
docker registry  			


How to run the imae 	       : >docker container run -p hostport:containerport imagename:tag 




9:00 AM to 12:00 AM

	|-Jenkins
	|-SonarQube
	|-source code -- compile -- jar 
	|-docker image
	|-push the image
	|-pull the image
	|-run the image


	
	